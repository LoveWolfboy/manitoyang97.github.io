{"meta":{"title":"XiaoQi's Blog","subtitle":"Serious life.","description":"专注于Web前端,分享生活,分享知识","author":"XiaoQi","url":"https://www.iamys.club","root":"/"},"pages":[{"title":"about","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:58:58.164Z","comments":true,"path":"about/index.html","permalink":"https://www.iamys.club/about/index.html","excerpt":"","text":""},{"title":"categories","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T12:59:50.241Z","comments":true,"path":"categories/index.html","permalink":"https://www.iamys.club/categories/index.html","excerpt":"","text":""},{"title":"contact","date":"2018-09-30T09:25:30.000Z","updated":"2020-04-08T13:00:58.441Z","comments":true,"path":"contact/index.html","permalink":"https://www.iamys.club/contact/index.html","excerpt":"","text":""},{"title":"tags","date":"2018-09-30T10:23:38.000Z","updated":"2020-04-08T12:54:45.821Z","comments":true,"path":"tags/index.html","permalink":"https://www.iamys.club/tags/index.html","excerpt":"","text":""},{"title":"friends","date":"2018-12-12T13:25:30.000Z","updated":"2020-04-08T13:02:15.797Z","comments":true,"path":"friends/index.html","permalink":"https://www.iamys.club/friends/index.html","excerpt":"","text":""}],"posts":[{"title":"mongoDB接数据库","slug":"mongoDB接数据库","date":"2020-04-17T08:00:43.065Z","updated":"2020-04-17T08:00:59.956Z","comments":true,"path":"2020/04/17/mongoDB接数据库/","link":"","permalink":"https://www.iamys.club/2020/04/17/mongoDB%E6%8E%A5%E6%95%B0%E6%8D%AE%E5%BA%93/","excerpt":"","text":"mongoDB数据库如何连mongoDB接数据库 下载mongoos第三方模块npm install mongoose 引入mongoose第三方模块，用来操作数据库 用connect方法来连接数据库，参数为mongodb://localhost/playground，最后一个是数据库名写上就会自动创建 分别用.then和.catch对数据库连接成功或失败一个反馈 const mongoose = require(&#39;mongoose&#39;) mongoose.connect(&#39;mongoose://localhost/playground&#39;) .then(() =&gt; console.log(&#39;数据库连接成功&#39;)) .catch(() =&gt; console.log(&#39;数据库连接失败&#39;))如何创建一个集合以及向集合插入文档 创建集合规则，用new实例化mongoose，用Schema方法添加规则，规则为字段名和类型 创建集合，model方法第一个参数是集合名第二个参数是集合规则 创建文档，用new实例化集合，参数为一个对象每一项是具体的字段和值 将文档保存到数据库，文档名.save() const personSchema = new mongoose.Schema({ name: String, age: Number, hobbies: [String] }) const Person = mongoose.model(&#39;Person&#39;, personSchema) const person = new Person({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) person.save()集合插入文档的另一种方式之前我们插入文档是用new实例化集合，还有一个方式是用集合.create方法参数是一个对象，里面是具体的字段和值，可以用.then查看结果。 Person.create({ name: &#39;zhangsan&#39;, age: 12, hobbies: [&#39;sing&#39;, &#39;read&#39;] }) .then(result =&gt; { console.log(result); })文档查询文档查询之前可以先建立一个用户信息文件如user.json { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f1e5aeb04b22f8460965&quot; }, &quot;name&quot;: &quot;张三&quot;, &quot;age&quot;: 20, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;, &quot;橄榄球&quot;], &quot;email&quot;: &quot;zhangsan@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f236aeb04b22f8460967&quot; }, &quot;name&quot;: &quot;李四&quot;, &quot;age&quot;: 10, &quot;hobbies&quot;: [&quot;足球&quot;, &quot;篮球&quot;], &quot;email&quot;: &quot;lisi@itcast.cn&quot;, &quot;password&quot;: &quot;654321&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f267aeb04b22f8460968&quot; }, &quot;name&quot;: &quot;王五&quot;, &quot;age&quot;: 25, &quot;hobbies&quot;: [&quot;敲代码&quot;], &quot;email&quot;: &quot;wangwu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f294aeb04b22f8460969&quot; }, &quot;name&quot;: &quot;赵六&quot;, &quot;age&quot;: 50, &quot;hobbies&quot;: [&quot;吃饭&quot;, &quot;睡觉&quot;, &quot;打豆豆&quot;], &quot;email&quot;: &quot;zhaoliu@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2b6aeb04b22f846096a&quot; }, &quot;name&quot;: &quot;王二麻子&quot;, &quot;age&quot;: 32, &quot;hobbies&quot;: [&quot;吃饭&quot;], &quot;email&quot;: &quot;wangermazi@itcast.cn&quot;, &quot;password&quot;: &quot;123456&quot; } { &quot;_id&quot;: { &quot;$oid&quot;: &quot;5c09f2d9aeb04b22f846096b&quot; }, &quot;name&quot;: &quot;狗蛋&quot;, &quot;age&quot;: 14, &quot;hobbies&quot;: [&quot;打豆豆&quot;], &quot;email&quot;: &quot;goudan@163.com&quot;, &quot;password&quot;: &quot;123456&quot; }创建好集合之后用：mongoimport -d 数据库名 -c 集合名 --file 要导入文件的路径 find()查询指定集合的所有文档 Person.find().then(result =&gt; console.log(result))find({条件})查询指定集合中满足条件的文档 Person.find({name:&#39;李四&#39;}).then(result=&gt;console.log(result))find({字段:{$gt:开始范围 , $lt: 结束范围}})查询字段位于之间的文档 &amp;lt小于 &amp;gt大于 Person.find({age:{$gt:20,$lt40}}).then(result=&gt;console.log(result))find({字段:{$in:包含项}}) Person.find({hobbies:{$in:[&#39;sing&#39;]}}).then(result=&gt;console.log(result))find().select(‘字段1，字段2..’)查询指定字段，字段前加-，可以去除字段 Person.find().select(&#39;name,age,-id&#39;).then(result=&gt;console.log(result))find().sort(‘排序字段’)默认按升序排序，加-按降序排序 Person.find().sort(&#39;-age&#39;).then(result=&gt;console.log(result))find().skip(跳过的条数).limit(限制显示结果的条数) Person.find.skip(2).limit(3).then(result=&gt;console.log(result))findOne()返回指定集合第一个文档 Person.findOne().then(result=&gt;console.log(result))findOne({条件})返回指定集合满足条件的第一个文档 Person.findOne({age:14}).then(result=&gt;console.log(result))删除文档查找一条文档并且删除，返回的是删除的文档，匹配多个文档会删除第一条 Person.findOneAndDelete({name:&#39;张三&#39;}).then(result =&gt; console.log(result))删除多个文档，不加条件会删除全部文档 Person.deleteMany({}).then(result =&gt; console.log(result))更新文档更新一条文档 Person.updateOne({ name: &#39;李四&#39; }, { name: &#39;李小四&#39;, age: 18 }).then(result =&gt; console.log(result))更新全部文档 Person.updateMany({}, { age: 0 }).then(result =&gt; console.log(result))mongoose验证在集合规则中有很多验证规则 required必填项，typt字段类型，minlength最小长度，maxlength最大长度，min最小值，max最大值，trim:true去掉首尾空格，default默认值，enum:{values:[]}枚举，validate:{validator:v=&gt;{return v&amp;&amp;v.length&gt;4}}自定义验证程序 message错误提示的获得，在向集合插入文档时的错误信息定义成如下 .catch(error =&gt; { // 获取错误信息对象 const err = error.errors; // 循环错误信息对象 for (var attr in err) { // 将错误信息打印到控制台中 console.log(err[attr][&#39;message&#39;]); } })集合关联const userSchema = new mongoose.Schema({ name: { type: String, required: true } }); const postSchema = new mongoose.Schema({ title: String, author: { //类型为id，固定写法 type: mongoose.Schema.Types.ObjectId, //关联集合user ref: &#39;User&#39; } }) const Post = mongoose.model(&#39;Post&#39;, postSchema); const User = mongoose.model(&#39;User&#39;, userSchema) Post.create({ title: &#39;123&#39;, author: &#39;5c0caae2c4e4081c28439791&#39; }).then(result =&gt; console.log(result)); User.create({ name: &#39;李四&#39; }).then(result =&gt; console.log(result)) //populate()关联集合查询 Post.find().populate(&#39;author&#39;).then(result =&gt; console.log(result))","categories":[],"tags":[]},{"title":"hexo+github搭建博客","slug":"博客搭建","date":"2020-04-10T16:00:00.000Z","updated":"2020-04-11T14:06:46.626Z","comments":true,"path":"2020/04/11/博客搭建/","link":"","permalink":"https://www.iamys.club/2020/04/11/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/","excerpt":"","text":"前言作为一个一直追随大佬脚步的小菜鸟，一直都想有一个属于自己的博客，但是一直没有付诸行动（主要是不会），但是偶然的一天看到一篇公众号文章标题大概是这样“十分钟带你搭建一个博客”嗯就是这样一个标题激起了我心中的博客之念想，开始蠢蠢欲动跟着步骤来开始了我的踩坑之路。 一、准备工作0.注册/登录一个GitHub账户，建立一个公开的仓库并且仓库名一定要是：用户名.github.io 1.下载node并配置好环境变量（我的第一个坑就是node没有配置环境变量）安装直接一直下一步即可 2.下载git配置好环境变量（如果不太了解可以看一下廖雪峰的教程） 二、搭建过程为git配置信息window+r打开cmd打开终端配置git信息输入如下信息： git config -g user.name &quot;你的github用户名&quot;git config -g user.emil &quot;你注册github的邮箱&quot;生成密钥在终端输入如下命令： ssh -keygen -t rda -C &quot;你注册github的邮箱&quot;之后不管内容三个回车即可 复制密钥并且粘贴到github上面的密钥会生成到c盘的用户文件夹里面，如果找不到就在c盘搜索id_rsa.hub，然后打开把里面的内容都复制下来，登录到你的github点击右上角你头像，会出现一个下拉菜单找到setting，选择SSH and GPG keys,点击new ssh key，然后只需要把你复制的密钥粘贴上去即可，名字随意取。 此时可以来测试一下你的密钥是否配置成功 输入如下命令： ssh -T git@github.com选择yes，如果看到...successfull..那就是成功了 hexo安装hexo是一个集成的博客框架，可以快速根据主题生成静态网页 此时我们可以选择盘符新建一个空文件夹名为为blog，鼠标右键选择git bach here 安装hexo在里面执行如下语句： npm i -g hexo-cil这里时间可能会久一点，因为是在外网下载，如果时间太久或者下载失败的话可以用淘宝的镜像下载 如下 npm i -g cnpm --registry=https:registry.npm.taobao.orgcnpm i -g hexo-cilcnpm i hexo --save如果下载安装好了可以用hexo -v来查看如果看到版本信息就算安装成功如hexo-cil:4.1.0 初始化hexohexo init然后进入blog文件夹 如果你看到有source themes和_config.yml等文件夹就说明你操作成功 在本地服务器上查看hexo s接着打开浏览去器输入locahost:4000，就可以查看了，实际上这时候你的博客已经搭建成功了 嗯快一定的话网速好一点的话（最好是在科学上网的情况下）确实是十分钟，但是后面完善特别是我这种追求主题美观（花里胡哨）的人并且喜欢魔改主题又费了老大劲了，也是踩坑无数，主题魔改可单独一篇讲。 三、发布文章发布一篇文章可以用命令 hexo new &lt;标题&gt;但是强烈推荐里用Typora软件直接写拖到soruce的_posts文件夹里，这个文件夹是专门放你的博客文章的，但是只是放进去在网上还是不能看到你的文章，用命令生成网页在这之前最好先清理缓存 hexo cleanhexo g你可以先预览一下 hexo s和之前一样在浏览器上输入locahost:4000就可以看到你的文章 现在只是在本地能看到想要传到网上首先你需要在之前创建的blog文件夹里面找到_config.yml这个站点配置文件 打开滑倒最下面找到deploy下面的type后面写上git （注意type和git之间一点要有空格） 然后就可以部署到github上去，输入如下命令 hexo d四、主题配置你可能对默认的主题很不满意，你可以去hexo的主题库去挑选，下载的话建议直接点进github克隆主题仓库下载快一点，下载好之后将文件解压把文件发在theme这个文件夹里，然后点进根目录也就是刚才的blog文件下的站点配置文件--config.yml里找到theme在后面修改为你刚刚下载的主题文件夹名（也要注意theme和主题名之间的空格） 在这推荐几个功能完善好看的主题：nexT 极简风格，yilia 简单优雅 还有我的博客是主题目前是matery 想看可以点这里","categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.iamys.club/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"博客搭建/hexo","permalink":"https://www.iamys.club/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.iamys.club/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"hexo","permalink":"https://www.iamys.club/tags/hexo/"}]},{"title":"初识jQuery","slug":"jQuery","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-11T14:07:22.863Z","comments":true,"path":"2020/04/10/jQuery/","link":"","permalink":"https://www.iamys.club/2020/04/10/jQuery/","excerpt":"","text":"初始jQuery什么是jQueryjQuery是一个快速、简洁的javascript库，它里面封装了JavaScript常用大的功能代码，优化了DOM操作、事件处理、动画设计和Ajax交互，学习jQuery的本质就是学习调用这些函数（方法）； jQuery的优点 轻量级。核心文件才几十kb，不会影响页面大的加载速度 跨浏览器兼容。基本兼容了现在主流大的浏览器 链式编程，隐式迭代 ( 隐式迭代就是把匹配的所有元素内部进行遍历循环) 对事件、样式、动画支持，大大简化大的DOM操作 支持插件扩展开发。有着丰富大的第三方插件，如树形菜单、日期控件、轮播图等 免费、开源 简单的使用jQuery1.jQuery的入口函数 $(function() { $(&#39;div&#39;).hide();//此处是DOM加载完成的入口，相当与原生的DOMContentLoaded })2.jQuery的顶级对象$ ​ $是jQuery的别称，在代码中jQuery和$可以互换 ​ $是jQuery的顶级对象，相当于原生的的window，帮元素利用$包装成jQuery对象，就可以调用jQuery的方法。 DOM对象和jQuery对象的区别 用原生js获取来的对象就是DOM对象 var myDiv = document.querySelector(&#39;div&#39;); // myDiv 是DOM对象 jQuery方法获取的元素就是jQuery对象 $(&#39;div&#39;); // $(&#39;div&#39;)是一个jQuery 对象 jQuery对象的本质是：利用$对DOM对象大的包装后生产的对象（伪数组形式储存） DOM对象和jQuery对象之间是可以相互转换的 因为原生js比jQuery更大，原生的一些属性和方法jQuery没有给我们封装。要是想要这些属性和方法需要把和jQuery对象转换成DOM对象才能使用 DOM对象转换为jQuery对象 $(DOM对象) $(&#39;div&#39;) jQuery对象转换为DOM对象(两种方式) $(&#39;div&#39;)[index] //index是索引号$(&#39;div&#39;).get(index)jQuery的基本操作能写出常用的jQuery选择器基础选择器$(&quot;选择器&quot;) //直接写css选择器，但是一定要加双引号 用法 名称 描述 $(“#id”) Id选择器 获取指定ID元素 $(“*”) 全选选择器 匹配所有元素 $(“.class”) 类选择器 获取同一类元素 $(“div”) 标签选择器 获取同一类标签的所有元素 $(“div,p,li”) 并集选择器 选取多个元素 $(“li.current”) 交集选择器 交集元素 层级选择器 名称 用法 描述 子代选择器 $(“ul&gt;li”) 使用&gt;号，获取亲儿子层级的元素；注意不会获取到孙子层级的元素 后代选择器 $(“ul li”) 使用空格，代表后代选择器，获取ul下的所有li元素，包括孙子 筛选选择器 语法 用法 描述 :first $(“li:first”) 获取第一个li元素 :last $(“li:last”) 获取最后一个li元素 :ed(index) $(“li:ed(2)”) 获取li元素中，选择索引号为2的元素 :odd $(“li:odd”) 获取li元素中，选择索引号为奇数的元素 :even $(“li:even”) 获取li元素中,选择索引号为偶数的元素 筛选方法(重点) 语法 用法 说明 parent() $(“li”).parent(); 查找父级 children(selector) $(“ul”).children(“li”); 相当于$(“ul&gt;li”),最近一级(亲儿子) find(selector) $(“ul”).find(“li”); 相当于$(“ul li”),后代选择器 siblings(selector) $(“.first”).siblings(“li”); 查找兄弟节点。不包括自己 nextAll([expr]) $(“.first”).nextAll() 查找当前元素之后所有的同辈元素 prevtAll([expr]) $(“.last”).pravAll() 查找当前元素之前所有的同辈元素 hasClass(class) $(“div”).hasClass(“protected”) 查找当前元素是否含有某个特定的类，如果有则返回true eq(index) $(“li”).eq(2) 相当于$(“li:eq(2)”),index从0开始 重点记住：parent() children() find() siblings() eq() 能够操作jQuery样式操作css方法jQuery可以使用css方法来修改简单元素样式；也可以操作类，修改多个样式。 1.参数只写属性名，则返回属性值 $(this).css(&quot;color&quot;);2.参数是属性名，属性值，逗号分隔，是设置一组样式，属性必须加引号，值如果是数字可以不用单位和引号 $(this.css(&quot;color&quot;,&quot;red&quot;);3.参数可以是对象形式，方便设置多组样式。属性名和属性值用冒号隔开，属性可以不加引号 $(this).css(&quot;color&quot;:&quot;white&quot;,&quot;font-size&quot;:&quot;20px&quot;)设置类样式方法作用等同于以前的classList，可以操作类样式，注意操作类里面的参数不要加点 1.添加类 $(&quot;div&quot;).addClass(&quot;current&quot;);2.移除类 $(&quot;div&quot;).removeClass(&quot;current&quot;);3.切换类 $(&quot;div&quot;).toggleClass(&quot;current&quot;);类操作与ClassName区别原生js中的ClassName会覆盖原先里面的类名 jQuery里面的类操作只是对指定类进行操作，不会影响原先的类名。 能够写出常用的jQuery动画1.显示隐藏 show() hide() toggle()show([speed,[easing],[fn]]) //(1) 参数都可以省略，无动画直接显示 (2)speed：三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值 (3)easing:(Optional)用来指定切换效果，默认是&quot;swing&quot;，可用参数&quot;linear&quot;. (4) fn:回调函数，在动画完成时执行的函数，每个元素执行一次 下面的相同2.滑动 sideDown() sideUp() sideToggle()3.淡入淡出 fadeIn() fadeOut() fadeToggle() fadeTo()fadeTo(speed,opacity,[easing],[fn]) //(1)opacity 透明度必须写，取值0-1之间 (2)speed 三种预定速度之一的字符串(&quot;slow&quot;,&quot;narmal&quot;,&quot;fast&quot;)或者表示动画时长的毫秒数值必须写4.自定义动画 animate()animate(params,[speed],[easing],[fn]) //params 想要更改的属性，以对象的形式传递，必须写，属性名可以不写引号，复合属性采用驼峰命名方式5.动画或效果队列及其停止排队方法动画或者效果一旦触发就会执行，如果多次触发，就会造成多个动画或者效果排队执行。 stop() //用于停止动画或者效果，一定要写到动画前面，相当于停止结束上一次的动画能够操作jQuery属性设置获取元素固有属性值prop()所谓元素固有属性就是元素本身自带的属性； 1.获取属性的语法prop(&quot;属性&quot;)2.设置属性语法prop(&quot;属性&quot;，&quot;属性值&quot;)设置或获取元素自定义属性attr()用户给元素添加大的属性； 1.获取属性语法attr(&quot;属性&quot;) //类似原生getAttribute2.设置属性语法attr(&quot;属性&quot;,&quot;属性值&quot;) //类似原生setAttribute数据缓存data()data() 方法可以在指定的元素上存取数据，并不会修改DOM元素结构。一旦页面刷新，之前存放的数据都会移除。 1.附加数据语法data(&quot;name&quot;,&quot;value&quot;) //向被选元素附加数据2.获取数据语法data(&quot;name&quot;) //向被选元素获取数据同时还可以读取HTML5自定义属性data-index，得到的是数字型 能够操作jQuery元素内容文本值主要针对元素的内容还有表单的值操作 1.普通元素内容html()(相当于原生inneHTML)html() //获取元素的内容html(&quot;内容&quot;) //设置元素的内容2.普通元素文本内容text() (相当与原生innerText)text() //获取元素文本内容text(&quot;文本内容&quot;) //设置元素文本内容3.表单的值val()(相当于原生value)遍历元素jQuery隐式迭代是对同一类元素作了同样的操作，如果想要给同一类做不同的操作，就要用到遍历 语法1$(&quot;div&quot;).each(function(index,domEle){xxx;})1.each()方法遍历匹配的每一个元素。主要用DOM处理。each每一个 2.里面大的回调函数有两个参数：index是每个元素的索引号；domEle是每隔DOM元素对象不是jQuery对象 3.所以想要使用jQuery方法，需要给这个dom元素转换为jQuery对象$(domEle) 语法2$.each(object,function(index,element){xxx;})1.$.each()方法可用于遍历任何对象，主要是数据处理。比如数组对象 2.里面的函数有2个参数：index是每个元素的索引号；element遍历内容 添加元素1.内部添加element.append(&quot;内容&quot;)把内容放入匹配元素内部最后面，类似原生appendChild element.prapend(&quot;内容&quot;)2.外部添加element.after(&quot;内容&quot;) //把内容放入目标元素后面element.before(&quot;内容&quot;) //把内容放入目标元素前面内部添加元素，生成之后，他们是父子关系 外部添加元素，生成之后，他们是兄弟关系 删除元素element.remove() //删除匹配的元素（本身）element.empty() //删除匹配的元素集合中的所有子节点element.html(&quot;&quot;) //清空匹配的元素内容事件处理事件处理on()绑定事件on()方法在匹配元素上绑定一个或多个事件处理函数 element.on(events,[selector],fn)1.events:一个或多个空格分隔的事件类型，如click或者keydown 2.selector：元素的子元素选择器 3.fn：回调函数，即绑定在元素身上的侦听函数 on()方法的优势1.可以绑定多个事件 多个事件处理程序$(&quot;div&quot;).on({ mouseover:function(){}, mouseout:function(){}, click:function(){} });如果事件处理程序相同 $(&quot;div&quot;).on(&quot;mouseover mouseout&quot;,function(){ $(this).toggleClass(&quot;current&quot;); });2.可以事件委派操作，事件委派的定义就是，把原来加给子元素事件绑定在父元素身上，就是把事件委派给父元素$(&#39;ul&#39;).on(&#39;click&#39;,&#39;li&#39;,function(){ alert(&#39;hello world!&#39;); });在此之前有bind(),live() delegate()等方法来处理事件绑定或者事件委派，最新版用on代替他们 3.动态创建的元素，click()没有办法绑定事件，on()可以给动态生成的元素绑定事件事件处理off()解绑事件off()方法可以移除通过on()方法添加的事件处理程序 $(&quot;p&quot;).off() //解绑p元素所有事件处理程序 $(&quot;p&quot;).off(&quot;click&quot;) //解绑p元素上面的点击事件 $(&quot;ul&quot;).off(&quot;click&quot;,&quot;li&quot;); //解绑事件委托如果事件只想触发一次，可以使用one()来绑定事件 自动触发事件trigger()有些时间希望自动触发，比如轮播图自动播放功能跟点击右侧按钮一致，可以利用定时器自动触发右侧按钮的点击事件，不必鼠标点击触发 element.click() //第一种简写方式element.trigger(&quot;type&quot;) //第二种自动触发模式$(&quot;p&quot;).on(&quot;click&quot;,function(){ alert(&quot;hi~&quot;); }); $(&quot;p&quot;).trigger(&quot;click&quot;); //此时自动触发点击事件，不需要鼠标点击jQuery事件对象事件被触发，就会有事件对象的产生。 element.on(events,[selector],function(event){})阻止默认行为：event.preventDefault() 或者 return false 阻止冒泡：event.stopPropagation jQuery对象拷贝如果想要把某个对象拷贝（合并）给另外一个对象使用，此时可以使用$.extend()方法 $.extend([deep],target,object,[objectN])1.deep:如果设为true为深拷贝，默认false为浅拷贝 2.target：要拷贝的目标对象 3.object1：代拷贝到第一个对象的对象 4.objectN：待拷贝到第N个对象的对象 5.浅拷贝是把被拷贝的对象复杂数据类型中的地址拷贝给目标对象，修改目标对象会影响被拷贝对象 6.深拷贝，前面加true，完全克隆（拷贝的对象，而不是地址），修改的目标对象不会影响被拷贝的对象。 jQuery多库共存jQuery使用$作为标识符随着jQuery的流行，其他js库也用这$作为标识符，这样一来就会引起冲突。需要一个解决方案，让jQuery和其他的js和其他的js库不存在冲突，可以同时存在。这就叫做多库共存。 解决方案1.把里面的$符号统一改为jQuery。比如jQuery(“div”) 2.jQuery变量规定新的名称：$.noConflict() 如： var xxx =$.noConflict(); jQuery插件1.jQuery插件库 http://www.jq22.com/ 2.jQuery之家http://www.htmleaf.com/ 使用步骤1.引入相关文件（jQuery文件和插件文件） 2.复制相关的html，css，js（调用插件） 常用插件1.瀑布流 2.图片懒加载(图片使用延迟加载在可提高网页下载速度，它也能帮助减轻服务器负载) 当我们页面滑动得到可视区域，在显示图片，使用插件库的EasyLazyload，注意此时引入的文件和js调用必须写在DOM元素（图片）最后面 3.全屏滚动（fullpage.js) GitHub：https://github.com/alvarotrigo/fullPage.js 中文翻译网：http://www.dowebok.com/demo/2014/77/ bootstrap中文文档https://v3.bootcss.com 能够操作jQuery元素尺寸、位置jQuery尺寸 语法 用法 width()/height() 取得匹配元素宽度和高度值 只算width/height innerWidth() /innerHeight() 取得匹配元素宽度和高度值 包含padding outerWidth()/outerheight() 取得匹配元素的宽度和高度值 包含padding、border outerWidth(ture)/outerHeight(ture) 取得匹配元素宽度和高度值 包含padding、border、margin 以上参数为空，则是获取相应值，返回的是 数字型 如果参数为数字，则是修改相应值 参数可以不必写单位 jQuery位置位置主要有三个：offset()、position()、scrollTop()/scrollLeft() 1.offset()设置或获取元素偏移offset()方法设置或返回被选中元素相当于文档的偏移坐标，跟父级没有关系 该方法有2个属性left、top、offset()、top 用于获取距离文档顶部的距离，offset().left用于获取距离文档左侧的距离。 可以设置元素的偏移：offset({top:10,left:30}); 2.position() 获取元素偏移position()方法用于返回被选元素相对于带有定位的父级偏移坐标，如果父级都没有定位，则以文档为准。这个方法只能获取不能设置偏移。 3.scrollTop() /scrollLeft()设置或获取元素被卷去的头不和左侧srcollTop()方法设置或返回被选元素被卷去的头部","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"}]},{"title":"初识vue","slug":"vue基础","date":"2020-04-09T16:00:00.000Z","updated":"2020-04-11T14:07:03.263Z","comments":true,"path":"2020/04/10/vue基础/","link":"","permalink":"https://www.iamys.club/2020/04/10/vue%E5%9F%BA%E7%A1%80/","excerpt":"","text":"vue模块语法Vue概述声明式渲染&gt;组件系统&gt;客户端路由&gt;集中式状态管理&gt;项目构建 优点：易用、灵活、高效 Vue基本使用目标：能够说出Vue基本用法 vue的基本使用步骤 提供标签填充数据 引入vue.js库文件 可以使用vue的语法做功能 把vue提供的数据填充到标签中 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;Hello Vue&#39; //在页面中打印这段字符 } }); &lt;/script&gt;细节分析： 实例参数分析 el：元素的挂载位置（值可以是css选择器，也可以是DOM元素） data：模型数据（值是一个对象） 插值表达式用法 将数据填充到HTML标签中 插值表达式支持基本计算 vue代码运行原理分析 vue代码通过可以通过vue框架编译成原生js代码 Vue模板语法目标：能够说出Vue的模板语法 模板语法概述如何理解前端渲染：把数据填充得HTML中 前端渲染的方式 原生js拼接字符串 使用前端模板引擎 使用vue特有的模板语法 模板语法概述 插值表达式 指令 事件绑定 属性绑定 样式绑定 分支循环结构 指令什么是指令 指令的本质就是自定义属性 指令的格式:以v-开始 v-cloak指令用法先提供样式,再在插值表达式中添加v-cloak指令 &lt;style&gt; [v-cloak] { display: none; } &lt;/style&gt; &lt;div id=&quot;app&quot;&gt; &lt;div v-cloak&gt;{{msg}}&lt;/div&gt; &lt;/div&gt; 插值表达式存在的问题:闪动 如何解决该问题:使用v-cloak指令 解决问题的原理:先隐藏,替换好值之后显示最终的值 数据绑定指令 v-text填充纯文本 相比插值表达式更加简洁 v-html填充HTMl片段 存在安全问题 只能本网站内部可以用 v-pre填充原始信息 显示原始信息,跳过编译过程 数据的响应式 如何理解响应式? h5中的响应式就是屏幕尺寸变化导致的样式变化,数据的响应式就是数据的变化导致页面内容的变化 什么是数据绑定?将数据填充到标签中 v-once 只编译一次,显示内容之后不再具有响应式功能 &lt;div v-once&gt;{{info}} &lt;/div&gt;双向数据绑定什么是双向数据绑定?当在表单输入域输入字符是页面的内容也会有所变化. 双向数据绑定分析v-model指令 &lt;div id=&quot;app&quot;&gt; &lt;div v-text=&#39;uname&#39;&gt;&lt;/div&gt; &lt;input type=&quot;text&quot; v-model=&#39;uname&#39;&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { uname: &#39;&#39; } }) &lt;/script&gt;MVVM设计思想M(model) 模型 js对象 V(view) 视图 页面的DOM VM(View-Madel) 视图模型 Vue DOM监听+数据绑定 视图和模型可以通过视图模型相互访问,也就是DOM元素和js对象通过Vue相互转换 事件绑定vue如何处理事件用v-on指令实现事件绑定 事件函数的调用方式事件函数参数的传递 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{num}} &lt;/div&gt; &lt;button v-on:click=&#39;num++&#39;&gt;点击3&lt;/button&gt; &lt;!-- 事件绑定简写形式 --&gt; &lt;button @click=&#39;num++&#39;&gt;点击4&lt;/button&gt; &lt;!-- 事件绑定函数名 默认会传递事件对象 它为第一个参数 --&gt; &lt;button v-on:click=handle1&gt;点击1&lt;/button&gt; &lt;!-- 事件绑定函数调用 可以传递参数 事件对象必须是最后一个参数 参数名必须是$event --&gt; &lt;button v-on:click=handle2(123,456,$event)&gt;点击2&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { num: 0 }, methods: { handle1: function(event) { console.log(event.target.innerHTML); }, handle2: function(a, b, event) { // 调用参数必须写this，它指向实例对象 this.num++ console.log(a, b, event.target.innerHTML); } } }); &lt;/script&gt;事件修饰符.stop阻止冒泡 &lt;a v-on:click.stop=&#39;handle&#39;&gt;&lt;/a&gt;.prevent 阻止默认行为 &lt;a v-on:click.prevent=&#39;handle&#39;&gt;&lt;/a&gt;按键修饰符.enter回车键 &lt;input v-on:keyup.enter=&#39;submit&#39;&gt;.delete删除键 &lt;input v-on:keyup.delete=&#39;handle&#39;&gt;自定义按键修饰符全局config.keyCodes对象 Vue.config.keyCodes.f1=112属性绑定Vue如何动态处理数据v-bind指令实现动态绑定数据 &lt;div id=&quot;app&quot;&gt; &lt;!-- v-bind动态绑定属性:是它的缩写 --&gt; &lt;a v-bind:href=&quot;url&quot;&gt;百度&lt;/a&gt; &lt;!-- &lt;a :href=&quot;url&quot;&gt;百度&lt;/a&gt; --&gt; &lt;button v-on:click=&#39;handle&#39;&gt;切换&lt;/button&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { url: &#39;http//www.baidu.com&#39; }, methods: { handle: function() { this.url = &#39;http://itcast.cn&#39;; } } }) &lt;/script&gt;v-madel的底层实现原理 &lt;div id=&quot;app&quot;&gt; &lt;div&gt;{{msg}} &lt;/div&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&quot;handle&quot;&gt; //v-bind v-on &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { msg: &#39;hello&#39; }, methods: { handle: function(event) { this.msg = event.target.value; } } }) &lt;/script&gt; &lt;input type=&quot;text&quot; v-bind:value=&quot;msg&quot; v-on:input=&#39;msg=$event.target.value&#39;&gt; &lt;input type=&quot;text&quot; v-model=&#39;msg&#39;&gt;样式绑定class样式处理对象语法 &lt;div v-bind:class=&quot;{active:isActive}&quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:class=&quot;[activeClass,errorClass]&quot;&gt;&lt;/div&gt;style样式处理对象语法 &lt;div v-bind:style=&quot;{color:activeColor,fontSize:fontSize} &quot;&gt;&lt;/div&gt;数组语法 &lt;div v-bind:style=&quot;[beseStyle,overrideingStyles]&quot;&gt;&lt;/div&gt;分支循环结构分支结构v-if和v-show的区别循环结构v-for遍历数组 &lt;li v-for=&#39;item in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;key的作用：帮助Vue区分不同的元素，从而提高性能 &lt;li :key=&#39;item.id&#39; v-for=&#39;{item,index} in list&#39;&gt;{{item}}+{{index}}&lt;/li&gt;基础案例简易计算器 通过v-nodel指令实现数值a和数值b的绑定 给计算按钮绑定事件,实现计算逻辑 将计算结果绑定到对应位置 &lt;div id=&quot;app&quot;&gt; &lt;h1&gt;简单计算器&lt;/h1&gt; 数字1：&lt;input type=&quot;text&quot; v-model=&#39;a&#39;&gt;&lt;br&gt; 数字2： &lt;input type=&quot;text&quot; v-model=&#39;b&#39;&gt;&lt;br&gt; &lt;button v-on:click=&#39;handle&#39;&gt;计算&lt;/button&gt; &lt;span v-text=&#39;result&#39;&gt;计算结果：&lt;/span&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { a: &#39;&#39;, b: &#39;&#39;, result: &#39;&#39; }, methods: { handle: function() { this.result = parseInt(this.a) + parseInt(this.b); } } }) &lt;/script&gt;tab栏切换 实现静态dUI效果： 用传统的方式实现标签结构和样式 基于数据重构UI效果：将静态的结构和样式重构基于Vue模板语法的形式，处理事件绑定和逻辑控制 &lt;div id=&quot;app&quot;&gt; &lt;div class=&quot;tab&quot;&gt; &lt;ul&gt; &lt;li v-on:click=&#39;change(index)&#39; :class=&#39;currentIndex==index?&quot;active&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt;{{item.title}} &lt;/li&gt; &lt;/ul&gt; &lt;div :class=&#39;currentIndex==index?&quot;current&quot;:&quot;&quot;&#39; :key=&#39;item.id&#39; v-for=&#39;(item,index) in list&#39;&gt; &lt;img :src=&quot;item.path&quot;&gt; &lt;/div&gt; &lt;/div&gt; &lt;/div&gt; &lt;script src=&quot;../js/vue .js&quot;&gt;&lt;/script&gt; &lt;script&gt; var vm = new Vue({ el: &#39;#app&#39;, data: { currentIndex: 0, //选项卡的当前索引 list: [{ id: 1, title: &#39;apple&#39;, path: &#39;images/01.jpg&#39; }, { id: 2, title: &#39;orange&#39;, path: &#39;images/02.jpg&#39; }, { id: 3, title: &#39;lemon&#39;, path: &#39;images/03.jpg&#39; }] }, methods: { change: function(index) { this.currentIndex = index; } } }) &lt;/script&gt;声明式编程：模板的结构和最终显示的效果基本一致 Vue常用特性目标：能够说出Vue的常用特性 表单操作 input单行文本 直接值文本域中添加v-model=’uname’,然后再到data里面给uname初始值 textarea多行文本 直接值文本域中添加v-model=’dect’,然后再到data里面给dect初始值 select下拉多选 单选方式 v-model=”occupation” 再到data里给一个初始值，多选方式 v-model=”occupation” multiple 数组的形式给初始值（给每个选项一个单独的value值） redio单选框 v-model=”gender ，data中给初始值（每个选项给一个value值） checkbox多选框 v-model=”hobby” data里以数组的方式给一个初始值（每个选项给一个单独的value值） 表单修饰符 number：转化为数值 trim：去掉开始和结尾空格 lazy：将input事件切换为change事件 &lt;input type=&quot;text&quot; v-model.number=&#39;age&#39;&gt;自定义指令当内置指令不满足要求时我们需要自定义指令 自定义的语法规则 //自定义获得焦点指令 Vue.directive(&#39;focus&#39;, { inserted: function(el) { //el表示指令所绑定的元素 el.focus(); } });自定义的指令用法 &lt;input type=&quot;text&quot; v-focus&gt;带参数的自定义属性 directives: { color: { bind: function(el, binding) { el.style.backgroundColor = binding.value; } }, focus: { //定义在实例中的局部指令 inserted: function(el) { el.focus(); } } }指令的用法 &lt;input type=&quot;text&quot; v-color=&quot;msg&quot;&gt; &lt;input type=&quot;text&quot; v-focus&gt;计算属性表达式可能比较复杂的时候，使用计算属性可以使模板内容更加简洁 计算属性的用法 computed: { reverseString: function() { return this.msg.split(&#39;&#39;).reverse().join(&#39;&#39;); //反转字符串 } }过滤器格式化数据，比如将字符串格式转换为首字符大写，将日期格式 转化为指定的格式 自定义过滤器 Vue.filter(&#39;upper&#39;, function(val) { return val.charAt(0).toUpperCase() + val.slice(1); //将第一个字母转换为大写slice字符截取 });过滤器的用法 &lt;div&gt;{{msg|upper}}&lt;/div&gt; &lt;div&gt;{{msg|upper|lower}}&lt;/div&gt; &lt;div :abc=&quot;msg|upper&quot;&gt;测试&lt;/div&gt;局部过滤器 filters: { upper: function(val) { return val.charAt(0).toUpperCase() + val.slice(1); } }带参数的过滤器Vue.filter(&#39;format&#39;,function(Value,arg)){ //value就是过滤器传过来的参数 }过滤器的使用&lt;div&gt;{{data|format('yyyy-MM-dd')}}&lt;/div&gt;侦听器在数据变化使执行异步或开销较大的操作可以使用侦听器 侦听器的用法 methods: { checkName: function(uname) { //使用定时任务模拟接口调用 var that = this; setTimeout(function() { if (uname == &#39;admin&#39;) { that.tip = &#39;用户名已存在，请更换一个&#39;; } else { that.tip = &#39;用户名可以使用&#39;; } }, 1000); } }, watch: { uname: function(val) { //调用后台接口验证用户名的合法性 this.checkName(val); //修改提示信息 this.tip = &#39;用户名正在验证…&#39;; } }生命周期主要阶段 挂载（初始化相关属性） beforeCreate 在实例初始化之后，数据观测和事件配置之前被调用 created 在实例创建完成后立即被调用 beforeMount 在挂载开始之前被调用 mounted 被新创建的vm.$el替换，并挂载到实例上去时候调用该钩子 更新（元素或组件的变更操作） beforeUpdate 数据更新使调用，发生在虚拟DOM打补丁之前 updated 由于数据更改导致虚拟DOM重新渲染和打补丁在这之后会调用该钩子 销毁（销毁相关属性）关属性） beforeDestroy 实例销毁之前调用 destroyed 实例销毁之后调用 综合案例目标：能够基于Vue实现案例效果","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"}]},{"title":"JavaScript进阶","slug":"js高级","date":"2020-04-05T16:00:00.000Z","updated":"2020-04-10T06:50:46.219Z","comments":true,"path":"2020/04/06/js高级/","link":"","permalink":"https://www.iamys.club/2020/04/06/js%E9%AB%98%E7%BA%A7/","excerpt":"","text":"1.面向对象和类的继承什么是面向对象面向对象是把事务分解成一个一个对象，以对象来划分问题，然后对象之间分工与合作。 面向对象的程序思维中，每一个对象都是功能中心，具有明确的分工。 面向对象编程具有灵活，代码可复用、容易维护和开发大的优点，适合多人合作的大型软件项目 面向对象的特性：封装性、继承性、多态性 面向对象的思维特点：1.抽取（抽象）对象公用的属性和行为组织（封装）成一个类（模板） 2.对类进行实例化，获取类的对象 面向对象编程我们考虑的是有哪些对象，按照面向对象的思维特点不断的创建对象，使用对象，指挥对象做事情 类和对象的关系对象对象是一个具体的事务，在javascript中，对象是一组无序的相关属性和方法的集合，所有的事物都是对象。 对象是由属性和方法组成的 属性：事物的特征，在对象中用属性来表示（常用名词） 方法：事物的行为，在对象中用方法来表示（常用动词） 类class在ES6中添加了类的概念，可以使用class关键字声明一个类，之后这个类来实例化对象。 类抽象了对象的公共部分，它泛指某一大类（class） 对象特指某一个，通过类实例化的一个具体的对象 使用class创建自定义类语法：class name{ //class body }创建实例：var xx = new name;注意：类必须使用new实例化对象 类的constructor构造函数constructor()方法是类的构造函数（默认方法），用于传递参数，返回实例对象，通过new命令生成对象实例时，自动调用该方法，如果没有显示定义，类内部会自动给我们创建一个constructor() 类添加方法语法： class Person{ constructor(name,age){ this.name=name; this.age=age; } say(){ console.log(this.name+&#39;你好&#39;)； } }什么是继承子类可以继承父类的一些属性和方法。 语法：class Father{ } class Son extends Father{ }super关键字super关键字用于访问和调用父类上的函数。可以调用父类的构造函数，也可以调用父类的普通函数 调用构造函数语法：class Person { //父类 constructor(surname){ this.surname = surname; } } class Student extends Person { //子类继承父类 constructor(surname,firstname){ super(surname); //调用父类的constructor(surname) this.firstname = firstname; //定义子类独有的属性 } }注意：子类在构造函数中使用super，必须放在this前面（必须先调用父类的构造方法在使用子类构造方法） 调用普通函数语法：class Father{ say(){ return &#39;我是爸爸&#39;; } } class Son extends Father { say(){ //super.say() super调用父类方法 return super.say()+&#39;的儿子&#39;; } } var damo = new Son(); console.log(damo.say());注意：在继承中的属性和方法查找原则是就近原则，如果实例化子类输出一个方法，先看子类有没有这个方法，如果有就执行子类的，如果没有就在父类中找有没有这个方法，如果有就执行父类的这个方法。 四个注意点1.在ES6中类没有变量提升，所以先定义类，再实例化对象 2.类里面的共用属性和方法一定要加this使用 3.类里面的this指向问题 4.constructor里面的 this指向实例化对象，方法里面的this指向这个方法的调用者 2.构造函数和原型使用构造函数创建对象概述在ES6之前没有引入类的概念，所以对象不是基于类创建的，而是 一种称为构造函数的特殊函数来定义对象和他们的特征 创建对象可以通过以下三种方式： 1，对象字面量 2，new Object() 3,自定义构造函数 构造函数构造函数是一种特殊的函数 ，主要用来初始化对象，即为对象成员变量赋初始值，它总与new一起使用，我们可以把对象中的共有属性和方法抽取出来，然后封装到这个函数里面 在js中使用构造函数要注意以下两点： 1.构造函数用于创建一类对象，其首字母要大写 2.构造函数要和new一起使用才有意义 new在执行时会做四件事情：1.在内存中创建一个新的空对象 2.让this指向这个新的对象 3.执行构造函数的代码，给这个新对象添加属性和方法 4.返回这个新对象（所以构造函数里面不需要return） 成员分类JavaScript的构造函数中可以添加一些成员，可以在构造函数本身上添加，也可以在构造函数内部的this上添加。通过这两种方法添加的成员，就分别称为静态成员和实例成员 静态成员：在构造函数本身上添加的成员为静态成员，只能由构造函数 本身来访问 实例成员：在构造函数内部创建的对象成员称为实例成员，只能由实例化的对象来访问 构造函数的问题构造函数的方法虽然很好用，但是存在浪费内存的问题，因为如果构造函数里面添加了方法这种复杂数据类型，我们每实例化一个对象就会开辟新的空间存放这种复杂数据类型，这样是很没有必要的，所以就有了构造函数的原型prototype 原型的作用构造函数原型prototype构造函数通过分配的函数是所有对象所共享的。 JavaScript规定，每一个构造函数都有一个prototype属性，指向另一个对象，注意这个prototype就是一个对象，这个对象的所有属性和方法都会被构造函数所拥有。 function Star(uname, age) { this.uname = uname; this.age = age; // this.sing = function() { // console.log(&#39;我会唱歌&#39;); // } } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(ldh.sing === zxy.sing); ldh.sing(); zxy.sing(); // 一般情况下,我们的公共属性定义到构造函数里面, 公共的方法我们放到原型对象身上我们可以把一些不变的方法，直接定义在prototype对象上，这样所有对象的实例就可以共享这些方法。 问答 1.原型是什么？ 一个对象，我们也称为原型对象 2.原型的作用是什么？ 共享方法 对象原型 proto对象都有一个属性proto指向构造函数的原型对象prototype，之所以我们对象可以使用构造函数prototype原型对象的方法和属性，就是因为对象有proto原型存在。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); ldh.sing(); console.log(ldh); // 对象身上系统自己添加一个 __proto__ 指向我们构造函数的原型对象 prototype console.log(ldh.__proto__ === Star.prototype); // 方法的查找规则: 首先先看ldh 对象身上是否有 sing 方法,如果有就执行这个对象上的sing // 如果么有sing 这个方法,因为有__proto__ 的存在,就去构造函数原型对象prototype身上去查找sing这个方法 对象原型proto和原型对象prototype是等价的 proto对象原型大的意义在于为对象的查找机制提供了一个方向，或者说是一条路线，但是它是一个非标准属性，因此在实际开发中，不可以使用这个属性，它只是内部指向原型对象prototype constructor构造函数对象原型__proto __和构造函数原型对象prototype里面都有一个属性constructor属性，constructor我们称为构造函数，因为它指回构造函数本身。 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype = { // 如果我们修改了原来的原型对象,给原型对象赋值的是一个对象,则必须手动的利用constructor指回原来的构造函数 constructor: Star, sing: function() { console.log(&#39;我会唱歌&#39;); }, movie: function() { console.log(&#39;我会演电影&#39;); } } var ldh = new Star(&#39;刘德华&#39;, 18); var zxy = new Star(&#39;张学友&#39;, 19); console.log(Star.prototype); console.log(ldh.__proto__); console.log(Star.prototype.constructor); console.log(ldh.__proto__.constructor);constructor主要用于记录该对象引用哪个构造函数，它可以让原型对象重新指向原来的构造函数 构造函数、实例、原型对象三者之间的关系原型链 function Star(uname, age) { this.uname = uname; this.age = age; } Star.prototype.sing = function() { console.log(&#39;我会唱歌&#39;); } var ldh = new Star(&#39;刘德华&#39;, 18); // 1. 只要是对象就有__proto__ 原型, 指向原型对象 console.log(Star.prototype); console.log(Star.prototype.__proto__ === Object.prototype); // 2.我们Star原型对象里面的__proto__原型指向的是 Object.prototype console.log(Object.prototype.__proto__); // 3. 我们Object.prototype原型对象里面的__proto__原型 指向为 null 扩展内置对象可以通过原型对象，对原来内置对象进行扩展自定义的方法，比如给数组增加自定义求偶数和的功能。 注意：数组和字符内置对象不能给原型对象覆盖操作Array.prototype = {},只能是Array.prototype.xxx = function(){}的方式 Array.prototype.sum = function() { var sum = 0; for (var i = 0; i &lt; this.length; i++) { sum += this[i]; } return sum; }; var arr = [1, 2, 3]; console.log(arr.sum()); console.log(Array.prototype); var arr1 = new Array(11, 22, 33); console.log(arr1.sum());访问对象成员的规则JavaScript成员查找机制 1.当访问一个对象的属性（包括方法）时，首先查找这个对象自身有没有该属性。 2.如果没有就查找它的原型（也就是proto指向的prototype原型对象） 3.如果还没有就查找原型对象的原型（Object的原型对象） 4.依次类推一直到找到Object为止（null） 5.proto对象原型的意义在于为对象成员查找机制提供了一个方向，或者说是一条线路 继承ES6之前并没有给我们提供extends继承，我们可以通过构造函数+原型对象模拟实现继承，被称为组合继承 call()调用这个函数，并且修改函数运行时的this指向 fun.call(thisArg,arg1,arg2,……)thisArg：当前调用函数this的指向函数 arg1，arg2：传递的其他参数 function fn(x, y) { console.log(&#39;我想喝手磨咖啡&#39;); console.log(this); console.log(x + y); } var o = { name: &#39;andy&#39; }; // 1. call() 可以调用函数 fn.call(); // 2. call() 可以改变这个函数的this指向 此时这个函数的this 就指向了o这个对象 fn.call(o, 1, 2); function Father(uname, age) { // this 指向父构造函数的对象实例 this.uname = uname; this.age = age; } function Son(uname, age, score) { // this 指向子构造函数的对象实例 Father.call(this, uname, age);// 借用父构造函数继承属性 this.score = score; } Son.prototype = new Father(); //借用原型对象继承方法 // 如果利用对象的形式修改了原型对象,别忘了利用constructor 指回原来的构造函数 Son.prototype.constructor = Son; // 这个是子构造函数专门的方法 Son.prototype.exam = function() { console.log(&#39;孩子要考试&#39;); } var son = new Son(&#39;刘德华&#39;, 18, 100); console.log(son);ES5新增的一些方法数组方法 迭代（遍历）方法：forEach()、map()、filter()、some()、every() array.forEach(function(currenValue,index,arr))currentValue:相当于当前项的值 index：数组当前项的索引 arr：数组对象本身 // forEach 迭代(遍历) 数组 var arr = [1, 2, 3]; var sum = 0; arr.forEach(function(value, index, array) { console.log(&#39;每个数组元素&#39; + value); console.log(&#39;每个数组元素的索引号&#39; + index); console.log(&#39;数组本身&#39; + array); sum += value; }) console.log(sum);array.filter(function(currenValue,index,arr))filter()方法创建一个新的数组，新数组中的元素是通过检查指定数组中符合条件的所有元素，主要用于筛选数组，它直接返回一个新的数组。 // filter 筛选数组 var arr = [12, 66, 4, 88, 3, 7]; var newArr = arr.filter(function(value, index) { // return value &gt;= 20; return value % 2 === 0; }); console.log(newArr);array.some(function(currenValue,index,arr))some()方法用于检测数组中的元素是否满足指定条件，就是查找数组中是否有满足条件大的元素，它返回值是布尔值，如果查找这个元素就返回true，找不到就返回false var arr = [&#39;red&#39;, &#39;green&#39;, &#39;blue&#39;, &#39;pink&#39;]; // 如果查询数组中唯一的元素, 用some方法更合适, arr.some(function(value) { if (value == &#39;green&#39;) { console.log(&#39;找到了该元素&#39;); return true; // 在some 里面 遇到 return true 就是终止遍历 迭代效率更高 } console.log(11); });字符串方法 trim()方法会从一个字符串的两端删除空白字符 str.trim()trim()方法并不影响原字符串本身，它返回的是一个新的字符串。 对象方法 Object.keys()用于获取对象自身的所有属性 Object.keys(obj)效果类似for…in 返回一个由属性名组成的数组 // 用于获取对象自身所有的属性 var obj = { id: 1, pname: &#39;小米&#39;, price: 1999, num: 2000 }; var arr = Object.keys(obj); console.log(arr); arr.forEach(function(value) { console.log(value); })Object.defineProperty()定义新属性或修改原有的属性 Object.defineProperty(obj,prop,descriptor)Object.defineProperty()第三个参数descriptor说明：以对象形式{}书写 value：设置属性的值 默认为undefined writable：值是否可以重写。true|false 默认为false enumerable：目标属性是否可以被枚举。true|false 默认false configurable：目标属性是否可以被删除或是否可以再次修改特性true|false 默认是false 3.函数进阶说出函数的多种定义和调用方式函数的定义方式1.函数声明方式function关键字（命名函数） function fn(){};2.函数表达式（匿名函数) var fun = function(){};3.new Function() var fn = new Function(&#39;参数1&#39;，&#39;参数2&#39;……,&#39;函数体&#39;) Function里面的参数必须是字符串格式 这种方式执行效率低，也不方便使用，因此使用较少 所有的函数都是Function的实例（对象） 函数也属于对象 函数的调用方式1.普通函数 function fn() { console.log(&#39;这是一个普通函数&#39;); } fn(); fn.call();2.对象的方法 var o = { sayHi: function() { console.log(&#39;这是对象的方法&#39;); } } o.sayHi();3.构造函数 function Star() { console.log(&#39;这是一个大写的构造函数&#39;); } new Star();4.绑定事件函数 var btn = document.querySelector(&#39;button&#39;); btn.onclick = function() { console.log(&#39;这是一个绑定事件函数&#39;); }5.定时器函数 setTimeout(function() { console.log(&#39;这是定时器函数&#39;) }, 1000);6.立即执行函数 (function() { console.log(&#39;这是一个立即执行函数&#39;); })()说出和改变函数内部this的指向函数内的this指向this的指向是当我们调用函数时确定的，调用的方式不同决定了this的指向不同，一般指向调用者。 调用方式 this指向 普通函数调用 window 构造函数调用 实例对象，原型对象里的方法也指向实例对象 对象的方法对象 该方法所属的对象 事件绑定方法 绑定的事件对象 定时器函数 window 立即执行函数 window 改变函数内部的this指向JavaScript提供了函数和方法帮助我们改变函数内部this的指向，常用的有bind() call() apply() call() var o = { name: &#39;andy&#39; } function fn(a, b) { console.log(this); console.log(a + b); } fn.call(o, 1, 23) //可以调用函数，可以改变this指向，可以传递普通参数 //主要应用于继承 function Father(uname, age, sex) { this.uname = uname; this.age = age; this.sex = sex; } function Son(uname, age, sex) { Father.call(this, uname, age, sex); } var son = new Son(&#39;刘德华&#39;, 12, &#39;男&#39;) console.log(son);apply() var o = { uname: &#39;andy &#39; } function fn(arr) { console.log(this); console.log(arr); } fn.apply(o, [&#39;hello&#39;]);//可以调用函数，可以改变this指向，但是第二个参数必须是数组 //apply主要应用于用数学内置函数求数组最大最小值 var arr = [12, 33, 77, 1, 0] var max = Math.max.apply(Math, arr) var min = Math.min.apply(Math, arr) console.log(max, min);bind() var o = { name: &#39;andy&#39; }; function fn(a, b) { console.log(this); console.log(a + b); }; var f = fn.bind(o, 1, 2); //不会调用函数 ，可以改变this的指向，返回的时改变后的新函数 f();// bind()的主要应用：函数我们不需要立即调用,但是又想改变这个函数内部的this指向此时用bind // 我们有一个按钮,当我们点击了之后,就禁用这个按钮,3秒钟之后开启这个按钮 var btn = document.querySelectorAll(&#39;button&#39;); for (var i = 0; i &lt; btn.length; i++) { btn[i].onclick = function() { this.disabled = true; setTimeout(function() { this.disabled = false; }.bind(this), 2000) } }说出严格模式的特点严格模式（strict modes）JavaScript变体的一种方式，即在严格的条件下运行js代码，它对正常的js语义做了一些更改： 消除了JavaScript语法的一些不合理，不谨慎之处，减少了一些怪异行为 消除了代码运行的不安全之处，保证了代码运行的安全 提高编译器效率，增加运行速度 禁用了ECMAScript的未来版本中可能会定义的一些语法，为未来的JavaScript做好了铺垫。 开启严格模式严格模式可以应用到整个脚本或个别函数中，因此在使用时，我们可以将严格模式分为为脚本开启严格模式和为函数开启严格模式两种情况。 为脚本开启严格模式&lt;scprit&gt; &#39;use strict&#39;; console,log(&quot;这是严格模式&quot;); &lt;/scprit&gt; //不常用，影响文件合成为函数开启严格模式 &lt;script&gt; (function() { &#39;use strict&#39;; })(); &lt;/script&gt;严格模式中的变化变量的变化 在正常模式下如果一个变量未声明就赋值默认是全局变量，在严格模式下禁止这样使用变量必须先用var声明再使用。 严禁删除已声明的变量 严格模式下this的指向问题 以前全局作用域函数this指向window，严格模式下全局作用域的函数this指向undefined 以前构造函数不加new调用当成普通函数调用且this指向window，严格模式下会报错 new实例化的构造函数还是指向创建的对象实例 定时器this还是指向window 事件、对象还是指向调用者 函数的变化 函数不能有重名的参数 函数必须声明在顶层，不能声明在for if 之类的里面 把函数作为参数和返回值传递高阶函数高阶函数是对其他函数进行操作的函数，它接收函数作为参数或将函数作为返回值输出 function fn(a, b, callback) { console.log(a + b); callback &amp;&amp; callback(); } fn(1, 2, function() { console.log(&#39;我是最后调用的&#39;); });function fn(){ return function() {}; } fn();说出闭包的的作用什么是闭包闭包是指有权访问另一个函数作用域中的变量的函数。简单说就是一个作用域可以访问另一个函数内部的局部变量。 闭包的作用闭包的主要作用：延伸了变量的作用范围 闭包案例循环注册点击事件 var lis = document.querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { lis[i].onclick = function() { console.log(i); } })(i); }循环中的setTimeout() //3秒钟后打印所有的li var lis = document.querySelector(&#39;.nav&#39;).querySelectorAll(&#39;li&#39;); for (var i = 0; i &lt; lis.length; i++) { (function(i) { setTimeout(function() { console.log(lis[i].innerHTML); }, 3000) })(i) }计算打车价格 说出递归的两个条件什么是递归：如果一个函数在内部可以调用其本身，那么这个函数就是递归函数，简单的说就是一个函数自己调用自己就是递归函数。递归函数的作用和循环时一样的。由于递归函数很容易发生“栈溢出”错误（stack overflow），所以必须加退出条件return。 递归的两个条件：一自身调用，二退出条件 //利用递归求1-n的阶乘 function fn(n) { if (n == 1) { return 1; } return n * fn(n - 1); } console.log(fn(4));//利用递归求斐波拉及数 function fun(i) { if (i == 1 || i == 2) { return 1; } return fun(i - 1) + fun(i - 2); } console.log(fun(4));说出深拷贝和浅拷贝的区别1.浅拷贝只拷贝一层，更深层次对象级别的只拷贝引用 Object.assign(target,…sources) es6新增的方法可以实现浅拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 } }; var o = {}; for (var k in obj) { //k是属性名，obg[k]是属性值 o[k] = obj[k]; } console.log(o); o.msg.age = 20;//这种复杂数据类型拷贝的是地址额，当一个改变原来的也会改变 console.log(obj); Object.assign(o, obj);2.深拷贝拷贝多层，每一次的数据都会拷贝 var obj = { id: 1, name: &#39;andy&#39;, msg: { age: 18 }, color: [&#39;pink&#39;, &#39;red&#39;] }; var o = {}; //封装函数 function deepCopy(newobj, oldobj) { for (k in oldobj) { var item = oldobj[k]; //判断数据类型 if (item instanceof Array) { newobj[k] = []; deepCopy(newobj[k], item); } else if (item instanceof Object) { newobj[k] = {}; deepCopy(newobj, item); } else { newobj[k] = item; } } } deepCopy(o, obj); o.msg.age = 90;//修改拷贝过的对象里的方法，原对象不会有影响 console.log(o); console.log(obj);4.正则表达式说出正则表达式的作用什么是正则表达式正则表达式是用于匹配字符串中字符组合的模式，在JavaScript中正则表达式也是对象 正则表达式的作用正则表达式通常用检索、替换那些符合某个模式（规则）的文本，例如验证表单：用户名，表单只能输入英文字母，数字或下划线，昵称可以输入中文（匹配）；此外，正则表达式还常用于过滤页面中内容的一些敏感词（替换）；或从字符串中提取我们想要的特定部分（提取）。 正则表达式的特点 灵活性、逻辑性和功能性非常强 可以迅速的用极为简单的方法达对字符串的复杂控制 对于刚接触的人可能比较晦涩难懂 实际开发一般都是直接复制写好的正则表达式，但是要求我们能看懂并且根据需求修改 写出简单的正则表达式创建正则表达式1.通过RegExp对象的构造寒素创建 var 变量名 = new RegExp(/表达式/)2.通过字面量创建 var 变量名 = /表达式/;测试正则表达式texttext()正则对象方法，用于检测字符串是否符合该规则，该对象会返回true或false，其参数式测试字符串 regexobj.text(str) regexobj是写的正则表达式 str是我们要测试的文本 作用是检测str文本是否符合我们写的正则表达式 正则表达式的组成一个正则表达式可以由简答的字符组成，比如/abc/，也可以是简单和特殊字符的组合，比如/ab*c/，其中特殊字符也被称为原字符，在正则表达式中具有特殊意义的符号，如^,$,+等。 边界符正则表达式中的边界符（位置符）用来提示字符所处的位置，主要由两个字符， 边界符 说明 ^ 表示匹配行首大的文本（从谁开始） $ 表示匹配行尾的文本（以谁结束） 字符类字符类有一系列的字符可供选择，只要匹配其中一个就可以了，所有可供选择的字符都放在方括号中就可以了。[a-z]表示从a到z。方括号里面可以使用字符组合如：[a-zA-Z0-9]；方括号中的^是取反符[^]。 量词符量词符用来设定某个模式出现的次数 量词 说明 * 重复零次或更多次 + 重复一次或更多次 ？ 重复一次或零次 {n} 重复n次 {n,} 重复n次或更多次 {n,m} 重复n到m次 括号总结 大括号 量词符 里面重复的次数 中括号 字符集合 匹配方括号中的任意字符 小括号 表示优先级 预定义类预定义类表示的是常见模式的简写方式 预定类 说明 \\d 匹配0-9之间的任意一个数字，相当于[0-9] \\D 匹配所有0-9之外的字符，相当于 [ ^ 0-9 ] \\w 匹配任意字母数字下划线，相当于[a-zA-Z0-9_] \\W 匹配所有字母数字下划线以外的字符，相当于[ ^a-zA-Z0-9_] \\s 匹配空格 换行符制表符空格符等 \\S 匹配非空格字符 使用正则表达式对表单进行验证使用正则表达式替换内容raplace()raplace()方法可以实现替换字符串操作，用来替换的参数可以是一个字符串或是一个正则表达式 stringObject.replace(regexp/substr,replacement) 第一个参数：被替换的字符串或者正则表达式 第二个参数：替换为大的字符串 返回值十一和替换完毕的新字符串 正则表达式参数/表达式/[switch]switch（也称为修饰符）按照什么样的模式匹配，有三种值 g：全局匹配 i：忽略大小写 gi：全局匹配+忽略大小写 5.ES6ES6概述什么是ES6ES的全ECMAScript，它是由ECMA国际标准化组织制度的一项脚本语言的标准化规范，2015年的版本叫做ES2015，2016年的版本叫做ES2016……所以ES6实际上是泛指ES2015及后续的版本。 为什么要使用ES6每一次标准的诞生都意味着语言的完善，功能的加强。JavaScript本身有一些让人不满意的地方。比如变量的提升特性增加了程序运行的不可预测性，语法过于松散，实现相同的功能不同的人可能写出不同的代码…… 变量letES6中新增的声明变量的关键字 let的特点特点1：let声明的变量只在处于块级有效（大括号中定义的，只在大括号中有效） if(true){ let a =10; } console.log(a); //a is not defined注意：let声明的变量只在块级作用域下有效，但是var声明的变量不具有块级作用域的特性。 特点2：不存在变量提升（不能先用再声明） console.log(a); //a is not defined let a = 10 ;特点3：暂时性死区 var num = 10 if (true) { console.log(num); //因为在块级作用域有let关键字，所以var定义的全局不起作用，let在后面定义前面打印就会出错。 let num = 20; }let的经典面试题 var arr = []; for (var i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //2 arr[1](); //2 //关键点在于变量i是全局的，函数执行时输出的都是全局作用域下的i值 let arr = []; for (let i = 0; i &lt; 2; i++) { arr[i] = function() { console.log(i); } } arr[0](); //0 arr[1](); //1 //关键点在于每次循环都会产生一个块级作用域，每个块级作用域中的变量都是不同的，函数执行时输出的是自己上 一级（循环每次产生的块级作用域）作用域下的i值常量const作用：声明常量，常量就是值（内存地址）不会发生变化的量 特点1：具有块级作用域 if(true) { const a=10; } console.log(a); //a is not defined特点2：声明常量必须赋值 conts PI; //错误，PI没有赋初值特点3：常量赋值后，值不能修改 const PI = 3.14; PI = 100; //错误：Assignment to constant variable. const ary = [100, 200]; ary[0] = &#39;a&#39;; ary[1] = &#39;b&#39;; console.log(ary); //[&#39;a&#39; ,&#39;b&#39;] ary = [&#39;a&#39;, &#39;b&#39;]; // 错误 Assignment to constant variable.let、const、var的区别 var let const 函数级作用域 块级作用域 块级作用域 变量提升 不存在变量提升 不存在变量提升 值可更改 值可更改 值不可更改 解构赋值ES6中允许从数组中提取值，按照对应的位置对变量赋值，对象也可以实现解构。 数据解构数组解构允许我们按照一一对应的关系从数组中提取值然后将值赋给变量。 let [a, b, c] = [1, 2, 3]; console.log(a); //1 console.log(b); //2 console.log(c); //3当数组中的值和变量不是一一对应关系，变量的值就是undefined let [foot] = []; let [foo, bar] = [11]; console.log(foot, foo, bar); //undefined 11 undefined对象结构let person = { name: &#39;张三&#39;, age: 20 }; let {name,age} = person console.log(name); //张三 console.log(age); //20 let {name: myName} = person; //也可以使用别名获取 console.log(myName);箭头函数ES中新增的定义函数的方式 () =&gt; {} //如下 const fn = () =&gt; { console.log(123); } fn(); //如果函数体中只有一句代码并且代码的执行结果就是函数的返回值，函数体大括号可以省略 const sum = (n1, n2) =&gt; { return n1 + n2; } //可简写为： const sum = (n1, n2) =&gt; n1 + n2; console.log(sum(1, 2)); //如果形参只有一个参数可省略小括号 const fun = (v) =&gt; { alert(v); } //可简写为 const fun = v =&gt; { alert(v) } fun(7);箭头函数不绑定this关键字，箭头函数中的this，指向的是函数定义位置的上下文this 剩余参数剩余函数允许我们将不定数量的参数表示为一个数组 function sum(first, ...args) { console.log(first); //10 console.log(args); //[20,30,40] } sum(10, 20, 30, 40);剩余参数配合解构使用 let ary = [&#39;a&#39;, &#39;b&#39;, &#39;c&#39;, &#39;d&#39;]; let [s1, ...s2] = ary; console.log(s1); //&#39;a&#39; console.log(s2); //[&#39;b&#39;,&#39;c&#39;,&#39;d&#39;]Array的扩展方法扩展运算符（展开语法）1.扩展运算符可以将数组或者对象转为用逗号分隔的参数序列。 let ary = [1, 2, 3]; console.log(...ary); //1 2 3 注意这里逗号被当成了log的分隔符2.扩展运算符可以应用于合并数组 let ary1 = [1, 2, 3]; let ary2 = [3, 4, 5]; let ary3 = [...ary1, ...ary2]; console.log(ary3); //[1,2,3,4,5,6] ary1.push(...ary2); console.log(ary1); //[1,2,3,4,5,6]3.扩展运算符可以将类数组或可遍历的对象转换为真正的数组，以便调用数组的方法 let divs = document.querySelectorAll(&#39;div&#39;); let oDivs = [...divs]; oDivs.push(&#39;abc&#39;) console.log(oDivs); //[div, div, div, div, div, &quot;abc&quot;]构造函数的方法：Array.from()1.将类数组或可遍历的数组转换为真正的数组 let arrLike = { &#39;0&#39;: &#39;a&#39;, &#39;1&#39;: &#39;b&#39;, &#39;2&#39;: &#39;c&#39;, length: 3 }; let arr = Array.from(arrLike); console.log(arr); //[&quot;a&quot;, &quot;b&quot;, &quot;c&quot;]2.这个方法还可以接受第二个参数，作用类似于数组map方法，用于对每个元素进行处理，将处理后的值放入数组。 let arrLike = { &#39;0&#39;: &#39;2&#39;, &#39;1&#39;: &#39;3&#39;, &#39;2&#39;: &#39;4&#39;, length: 3 }; let arr = Array.from(arrLike, item =&gt; item * 2); console.log(arr); //[4, 6, 8]实例方法:find()用于找出第一个符合条件的数组成员，如果没有找回就返回undefined let ary = [{ id: 2, name: &quot;张三&quot; }, { id: 2, name: &quot;李四&quot; }]; let target = ary.find(item =&gt; item.id == 2); console.log(target); //{id: 2, name: &quot;张三&quot;}实例方法:findIndex()用于找到第一个符合条件的数组成员的位置，如果没有找到返回-1 let ary = [1, 5, 10, 15]; let index = ary.findIndex(value =&gt; value &gt; 9); console.log(index); //2实例方法:includes()表示某个数组是否包含给定值，返回的是布尔值 [1,2,3].includes(2) //trueString的扩展方法模板字符串ES6新增的创建字符串的方式，使用反引号定义 let name = `zhangsan`;模板字符串可以解析变量 let name = `zhangsan`; let sayHello = `hello my name is ${name}`; console.log(sayHello);模板字符串可以换行 let res = { name: &#39;张三&#39;, age: 12 } let html = ` &lt;div&gt; &lt;span&gt;${res.name}&lt;/span&gt; &lt;span&gt;${res.age}&lt;/span&gt; &lt;/div&gt;`; console.log(html);模板字符串可以调用函数 const fn = () =&gt; &#39;我是fn函数&#39; let html = `我是模板字符串 ${fn()}`; console.log(html)实例方法：starsWith()和endsWith() starsWith():表示参数字符串是否在原字符串的头部，返回布尔值 endsWith():表示参数字符串是否在原字符串的尾部，返回布尔值 let str = &#39;Hello ECMAScript 2015&#39;; let r1 = str.startsWith(&#39;Hello&#39;); //true console.log(r1); let r2 = str.endsWith(&#39;2016&#39;); //false console.log(r2)实例方法：repeat()表示将原字符重复n次返回一个新字符串 console.log(&quot;y&quot;.repeat(5)) //yyyyyset数据结构ES6提供了新的数据结构Set，它类似于数组，但成员的值都是唯一的，没有重复的。 Set本身是一个构造函数，用来生成Set数据结构。 const s = new Set();Set 函数可以接受一个数组作为参数，用来初始化。 const set = new Set([1,2,3,4,4]);实例方法 add(Value):添加某个值，返回Set结构本身 delete(value):删除一个值，返回一个布尔值，表示删除是否成功。 has(value):返回一个布尔值，表示该值是否为Set的成员 clear():清除所有成员，没有返回值 const s = new Set(); s.add(1).add(2); //向set结构中添加值 s.delete(2); //删除set结构中的2值 s.has(1) //表示set结构中是否有这个值，返回布尔值 s.clear() //清除s中的所有值遍历Set结构的实例与数组一样，也有forEach方法，用于对每个成员执行某种操作，没有返回值 s.forEach(value =&gt; console.log(value))","categories":[{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}],"categories":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.iamys.club/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"博客搭建/hexo","permalink":"https://www.iamys.club/categories/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/hexo/"},{"name":"web前端","slug":"web前端","permalink":"https://www.iamys.club/categories/web%E5%89%8D%E7%AB%AF/"}],"tags":[{"name":"博客搭建","slug":"博客搭建","permalink":"https://www.iamys.club/tags/%E5%8D%9A%E5%AE%A2%E6%90%AD%E5%BB%BA/"},{"name":"hexo","slug":"hexo","permalink":"https://www.iamys.club/tags/hexo/"},{"name":"jQuery","slug":"jQuery","permalink":"https://www.iamys.club/tags/jQuery/"},{"name":"vue","slug":"vue","permalink":"https://www.iamys.club/tags/vue/"},{"name":"JavaScript","slug":"JavaScript","permalink":"https://www.iamys.club/tags/JavaScript/"},{"name":"EC6","slug":"EC6","permalink":"https://www.iamys.club/tags/EC6/"}]}